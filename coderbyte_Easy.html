<script>
//1. FIRST REVERSE - reverse the letters of a string
function FirstReverse(str){
	 return str.split("").reverse().join("");
 }
//OR
function FirstReverse(str){
var res = ''; 
  for (var i = str.length - 1; i >= 0; i--) {
    res += str[i];
}
   return res;
}
FirstFactorial("abcdefgh"); //returns 'hgfedcba'

//2. FIRST FACTORIAL - find the factorial of a number
//WILL'S While..Loop, countdown
function FF(num){
    var ans = 1;
    while (num > 1){
        ans *= num;
        num -= 1;
    }
    return ans;
}
FF(5); //120

//RECURSIVE
function FirstFactorial(num) { 
  if (num > 1) { //greater than 1 and not 0, because on the last recursive call it would be 1 - 1, and then pass 0 to the next iteration to be multiplied!
    num = num * FirstFactorial(num - 1);
  }
  return num; 
}

//3. LONGEST WORD - find the longest word in a string of words
for(var i=0; i < parts.length; i++){
    if(parts[i].length > longestWord){
        longestWord = parts[i].length;
        Index = i;
    }
}
return parts[Index];


*//Regex Match.Sort.Shift
  return sen.match(/[\w]+/g).sort(function(a, b){return b.length - a.length})
    .shift();
//or
	return str.split(" ").sort(function(a,b){return b.length - a.length}).shift();


//4. Letter Changes - Change all letters in a string to the next one in the alphabet. If the new letter is a vowel, then Capitalize it.
  function LetterChanges(str) { 
    var res = "";
    for (var i = 0; i < str.length; i++) {
		var cur = str[i]; //needed for spaces to appear between words.
      if (str[i] == 'z') {
		  cur = 'a'; //important, not res+= a
      } else if (str.charCodeAt(i) >= 'a'.charCodeAt(0) && str.charCodeAt(i) <= 'z'.charCodeAt(0)) { //97a to 122z
		  cur = String.fromCharCode(str.charCodeAt(i) + 1);
      }
      if (cur == 'a' || cur == 'e' || cur == 'i' || cur == 'o' || cur == 'u') {
        cur = cur.toUpperCase();
      }
      res += cur;
    }
    return res;       
}

    
}
LC("how are you");

//5. Simple Adding - Given a number, add all the numbers below it
//WILL'S
function SimpleAdding(num){
var tot = 0;
for (i=1;i<=num;i++){
    tot += i;
}
return tot;
}
SimpleAdding(4); //10

**//OR recursive
function SimpleAdding(num) { 
  if(num === 1){
    return 1; 
  }
  return num + SimpleAdding(num - 1);
}

//6. LetterCapitilize - capitalize the first letter of each word
//WILL'S
var arr = str.split(' ');
var res = '';

for (i=0;i<arr.length;i++){
    for (j=0;j<arr[i].length;j++){
        if (j===0){
            res+= arr[i][j].toUpperCase()
        } else {
            res+= arr[i][j];
        }
    }
    res += ' ';
}
return res;
}
 
//7. Simple Symbols - letters must be surrounded by '+' (ie. ++d+===+c++==a) returns false
function SS(str){
for (i=0;i<str.length;i++){
    if (/\w/.test(str[i])){
        if (str[i-1]== '+' && str[i+1] == '+'){} else {
            return false;
        }
    }
}
return true;
    
}
SS("+a+d+===+c++==+a+"); //true

//8. Check Nums - true if num2>num1, otherwise false. -1 if equal
//EASY
if num2 > num1 {"true"} else if (num1>num2) {"false"} else "-1"


//9.TimeConvert = convert minutes(95) to hours:minutes
//EASY
function TimeConvert(num) { 
var hours = Math.floor(num / 60);
var minutes = num % 60;
	return hours + ":" + mins;
}
TimeConvert(95); //35 minutes           

	
//10. ALphabet Soup - alphabetize a string's chars  
//Re-Write without Methods...
function AlphabetSoup(str) { 
  var res=[];
  for(var i=0; i < str.length; i++) {
    res.push(str[i]);
  }
  return res.sort().join('');       
}
	
//Methods
function AlphabetSoup(str){}
split().sort().join() 
}

//11. AB Check  - Return true if the characters a and b are separated by exactly 3 places at least once, Otherwise return the string false. 
//WILL'S
function ABCheck(str) {  //question doesn't ask for all cases of a...b or like "a000b a1234b" but would be nice to write a REGEX for that
	function ABCheck(str) {  
	var reg2 = /b...a/;
	var reg = /a...b/;
		if (reg.test(str)){
		    return true;
		} else if (reg2.test(str)){
		    return true;
		} else {
		    return false;
		}
	}
}


//12. VOWEL COUNT - Return the number of vowels in the string
//WILL'S
function VowelCount(str) { 
count = null;
for(i=0;i<str.length;i++) {
    if (str[i]=='a' | //or use /a|e|i|o|u/g.test(str[i])
        str[i]=='e' |
        str[i]=='i' |
        str[i]=='o' |
        str[i]=='u') {
       count++;
    }
}
  return count; 
}

*//REGEX
function VowelCount(str) {
  return str.match(/[aeiou]/g).length;       
}
	
//13.Word Count - count the number of words in a string 
//do smtg for if there's a space at begining or end, as this will cause another word to be recorded..
//WILL'S ANSWER
function WordCount(str) { 
    if (str == "") {
           return 0;
    } else {
	return (str.split(" ")).length; 
	}
}
	
//same
function WordCount(str) { 
  var arr=str.split(" ");
  if (arr ==null){
    return 0;
  }
  else{
    return arr.length;
  }         
}

//using a counter variable for the number of spaces
function WordCount(str) { 
  var wordCount = 0;
  for (var i = 0; i<str.length; i++){
    if (str[i] == " "){
     wordCount++; 
    }else if (i == str.length-1){  //in case there's 0 words..
     wordCount++; 
    } 
  } 
  return wordCount;         
}

//14. Ex Oh - returne true if there's an equal amount of x's and o's , "xooxxxxooxo" returns false
//WILL'S REGEX
function ExOh(str) {
return str.match(/x/ig).length == str.match(/o/ig).length;
}
//WILL'S
function ExOh(str){
if (str.match(/x/g).length == str.match(/o/g).length){
    return true;
} else {return false}
}
ExOh("xoo"); //false                            
	
//15. Palindrome - check if a string input reads the same forwards as it does backwards
//WILL'S, without LIBRARIES
function Palindrome(str){
for (i=0,y=str.length-1;i<str.length;i++,y--){
    if (str[i]==str[y]){} else{
        return false;
    }
}
return true;
}
Palindrome("aab1bccddeef4feeddccb1baa");

//WILL'S
	function Palindrome(str){
	var original = str.toLowerCase();
	var reverse = str.toLowerCase().split("").reverse("").join("");
	return original == reverse;
	}
	Palindrome("aab2bccddeef1feeddccb2baa");
//WILL'S
    return str.split("").reverse().join("") == str;
	
//16.Arith Geo - Return "arithmetic" if the #'s follow an arithmetic sequence, return "gemoetric" if the #'s follow a geometric sequence. [2, 4, 6, 8] and or [2, 6, 18, 54]. Negative numbers may be entered as parameters, 0 will not be entered, and no array will contain all the same elements. */
//Arith Geo - 2 More Functions
function ArithGeo(arr){
	if (IsArith(arr)){ // or set it up like, return isArr(arr) || isGeo(arr) || -1;
    	return 'Arithmetic';
	}else if (IsGeom(arr)){
    	return 'Geometric';
	} else {
    	return -1;
	}
}

function IsArith(arr){
var arith = arr[1] - arr[0];
for (i=2; i<arr.length; i++){
    if (arr[i] - arr[i-1] == arith) {} else {
        return false;
    }
}
return true; //for my alternative answer below, this would return 'arithmetic'
}

function IsGeom(arr){
geom = arr[1] / arr[0];
for (i=2; i<arr.length; i++){
    if (arr[i] / arr[i-1] == geom){} else {
        return false;
    }
}
return true;
}
ArithGeo([2,4,6,8]);

//OR set it up like... :)
 return isArr(arr) || isGeo(arr) || -1;
	
//17. Array Addition I - return true if any combination of numbers in the array can be added up to equal the largest number in the array, otherwise return the string false. For example: if arr contains [4, 6, 23, 10, 1, 3] the output should return true because 4 + 6 + 10 + 3 = 23. The array will not be empty, will not contain all the same elements, and may contain negative numbers. 
function ArrayAddition(arr) { 
var tot = 0;
arr.sort(function(a,b){return b-a}); /

for (i=1;i<arr.length;i++){
    tot += arr[i];
}

if (tot >= arr[0]){
    return true;
} else {
    return false;
}
}
ArrayAddition([4, 6, 300, 10, 1, 3]);

//OR
function AAI(arr){
   var high = arr.sort(function(a,b){return b-a}).shift();
    var sum = arr.reduce(function(a,b){return a+b});
    
    if (sum >= high){
        return "equal or greather than the largest...";
    }
}

AAI([4, 6, 29, 10, 1, 3])
		
//18. Letter Count I
/*return the first word with the greatest number of repeated letters. For example: "Today, is the greatest day ever!" should return greatest because it has 2 e's (and 2 t's) and it comes before ever which also has 2 e's. If there are no words with repeating letters return -1. Words will be separated by spaces.*/
	
//
function LetterCountI(str) { 
  var words = str.split(' ');
  var maxLength = 0;
  for(var i=0;i<words.length;i++){
	  var hi = words[i].match(/([a-z])(?=.*\1)/ig); //if it doesn't match any, then value of hi will be null!
    if(hi !== null){ //need this, bc when hi will be equal to null when there are no repeating letters!
      if(hi.length>maxLength){
        maxLength = hi.length;
        var maxWord = words[i]; //or index = i;
      }
    }
  }
  return maxWord || -1; //or return words[i];
}

/*
(?= ... )
Lookahead, a zero-width assertion about what's coming up in the string, here used to assert:
(?=p) A positive look-ahead assertion. Require that the following characters match the pattern p, but do not include those characters in the match.	
http://stackoverflow.com/questions/13362987/regex-that-matches-a-string-only-with-question-marks	
\1 means 'the first subset'? or 'matches it into 1'?
Match the same characters that were matched when group number n was first matched. Groups are subexpressions within (possibly nested) parentheses. Group numbers are assigned by counting left parentheses from left to right. Groups formed with (?: are not numbered.
http://www.regular-expressions.info/lookaround.html
*/
	
//19.Second GreatLow
//Return the second lowest number and second highest numbers of an Array. Be able to do this for [80,80] which returns "80 80" and [5,-4,-4,10,2] which returns "2 5"
//WILL'S NEW SOLUTION ON APRIL 1ST - works for [5,-4,-4,10,2]
function SecondGreatLow(array){
	var arr = array.sort(function(a,b){return a - b}); //OR WRITE array = array.sort(function(a,b){return a-b}), this way don't have to create a 2nd variable
//add condition for if array is [80,80];
var init = arr[0];
var secondlow = 0;
for (i=1;i<arr.length;i++){
    if (arr[i]>init){ //if (arr[i+1] !== arr[i]){ doesn't work for [80,80]
        secondlow = arr[i]; 
        break;
    }
}
var last = arr[arr.length-1];
var secondhigh = 0;
for (i=arr.length-1;i>=0;i--){
    if (arr[i]<last){
        secondhigh = arr[i];
        break;
    }
}
return [secondlow,secondhihg].join(",");
}
SecondGreatLow([5,-4,-4,10,2]); //returns 2, 5

/*
if(arr.length == 2)
	return "" + Math.max(arr[0],arr[1]) + " " + Math.min(arr[0],arr[1]); */
	
//20. Division Stringifield - Divide num1 by num2, and return the numerical result as a string with properly formatted commas*/
//DONE
function DivisionStringified(num1,num2) { 
  var num = Math.round(num1/num2).toString().split("");
  var index = -3;
  while(num.length + index > 0){
    num.splice(index,0,",");
    index -= 4;
  }
  return num.join("");
}

*//21. Counting Minutes - Return the total number of minutes between two times. 9:00am-7:00am then the output should be 1320. Use exec
//REGEXP
function CountingMinutesI(str) { 
  var match = /(\d{1,2}):(\d{1,2})(am|pm)-(\d{1,2}):(\d{1,2})(am|pm)/.exec(str);
  
   var minute = function(h, m, ampm) {
      var time = 0;
       if (ampm == "pm"){
           time = (Number(h) + 12) * 60 + Number(m);
       } else {
           time = h * 60 + Number(m);
       }
    return time;
   };
  
  var time1 = minute(match[1], match[2], match[3]);
  var time2 = minute(match[4], match[5], match[6]);
  
  if(time2 < time1) {
      time2 += 24 * 60;
  }
  return time2 - time1;
}

CountingMinutesI("9:00am-7:00am"); //1320
	
//22 MeanMode
//Using the JavaScript language, have the function MeanMode(arr) take the array of numbers stored in arr and return 1 if the mode equals the mean, 0 if they don't equal each other (ie. [5, 3, 3, 3, 1] should return 1 because the mode (3) equals the mean (3)). The array will not be empty, will only contain positive integers, and will not contain more than one mode. 
//WILL'S
    //IF the object doesn't have the 'property' yet, then add it to the         object
    //ELSE if the object already has the property, then +1 it value (which      acts as the counter)

	//re-check all of the 'properties' in the object and see if their values     //are greater than the existing max value
function MeanMode(array){
    if (Mode(array)==Mean(array)){
        return 1;
    } else {
        return 0;
    }
}

function Mode(array){
var numObj = {};
var max = 0;
var index = '';
for (i=0; i<array.length; i++){
    if (!numObj.hasOwnProperty(array[i])) {
        numObj[array[i]] = 1;
    } else {
        numObj[array[i]] += 1;
    }
    for (var prop in numObj) {
    if (numObj[prop] > max) {
        max = numObj[prop];
        index = prop;
    }
}
}
return index;
}

function Mean(array){
    return array.reduce(function(a,b){return a+b}) / array.length;
}
MeanMode([5,3,3,3,1]); //returns true

  

//23. DashInsert - insert dashes between every 2 odd numbers
  function DashInsert(num){
  var ans=num.toString().split("");
  for (i=0;i<ans.length-1;i++) {
    if ((ans[i]%2 == 1) && (ans[i+1]%2 == 1)) { ans.splice(i+1,0,"-") }
  }
  return ans.join(""); 
}

//24. SwapCase - replace upper-case letters in a string with lower-case letters, and vice versa //swap = ""
function SwapCase(str) {  //
var swap = "";
for (i=0;i<str.length;i++){
    if (str[i] == str[i].toUpperCase()) { //can't use !== 0
        swap = swap + str[i].toLowerCase();
    } else if (str[i] == str[i].toLowerCase()) {
        swap = swap + str[i].toUpperCase();
    }
}    
return swap;   
}	

//
	function SwapCase(str) { 
	  return str.replace(/[a-z]/ig,function(x){
	    if(x == x.toUpperCase()) {
			return x.toLowerCase()
		}
	    return x.toUpperCase();
	  });
	}
	
//25. Number Addition - /*Return the numbers in a string, added up together. "88Hello 3World!" returns 91. Each string will contain at least one letter or symbol. */ 
//WILL'S'
	function NumberAddition(str) { 
	  var nums = str.match(/\d+/g); //be careful bc each number in the array that this returns, is actually a string
	  if (nums === null) {
	    return 0;
	  }
	  var sum = 0;
	  for (i=0; i<nums.length; i++) { //don't forget .length here
	      sum = sum + Number(nums[i]); //need Number method or it will concat
	  }
	 return sum;
	}
	NumberAddition("79Number9 okay2 mand 21");      
//
	function NumberAddition(str){
	    return str.match(/\d+/g).reduce(function(a,b){return Number(a)+Number(b)});
	}
	NumberAddition("88Hello 3World!");
	//OR return eval(nums.join('+'))
	}

//26. Third Greatest
/*Return third largest word in a string. ["hello", "world", "before", "all"] returns "before". ["hello", "world"] are both 5, but the output should be world because it appeared as the last 5 letter word in the array[I can accomodate this? Find a solution that does?]. If strArr was ["hello", "world", "after", "all"] returns "after" because its the 3rd word. (The array will have at least three strings and each string will only contain letters.*/
/*
WILL'S SOLUTION:
First, sort the array of strings by the length of its strings, so that "x" is index 0 and "ffff" is the last element in the newly sorted array

Next, the For statement records +1 to the counter variable for every time the length of the next element in the array is not equal to the length of the current element being iterated. This is important, because if consecutive elements are of equal length to each other, then you don't want your counter variable recording that we're advancing towards the "third largest" one.

Finally, when the counter variable reaches a value of 2 (which means that twice we've seen an increase in the length of the string being iterated, meaning we're now on the 3rd largest word), then its time to return this particular string as the 3rd largest!*/
//WILL'S, START...
	function TG(array){
	    array = array.sort(function(a,b){return a.length - b.length});

	var c = 0;
	for (i=1;i<array.length;i++){
	    if (array[i].length > array[i-1].length){
	        c++;
	    }
	    if (c==2){return array[i];}
	}
	}
	TG(["hello", "world", "after", "all"]);
	
	//WILL'S'
function ThirdGreatest(arr){
	arr.sort(function(a,b){return a.length - b.length});
	var c = 0;
	for(i=0;i<arr.length-1;i++){

	    if (arr[i].length !== arr[i+1].length){
	        c++;
	    }
	    if (c==2){
        
	        return arr[i+1];
	    }
	}
	if (c===0) {
	    return arr[1];
	} else if (c==1){
	    return arr[i];
	} else {
	return arr[0];
	}
	}
ThirdGreatest(["aaa", "c", "cc", "ffff","x", "dd"]); //aaa)
//doesn't work for ["hello", "world", "after", "all"]?????????????????? should return 'after;


*//27. Powers of Two
/*Return whether or not a number is a power of 2. 16 returns true, 22 returns false*/
	
*//recusive
function PowersofTwo(num) { 
  num /= 2;
  if(num == 1) return true;
  if(num % 1 !== 0) return false;
  return PowersofTwo(num); 
}
	
*//WHILE
function PowerofTwo(num){
    
    while (num >= 2){
    num = num / 2;
    if (num % 2 == 1){
        return true;
    }
    }
    
    return false;
}

//28. Additive Persistence
/*return the number of times you must add the digits in num until you reach a single digit. For example: if num is 2718 then your program should return 2 because 2 + 7 + 1 + 8 = 18 and 1 + 8 = 9 and you stop at 9.*/
  ////??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
  function AdditivePersistence(num) { 
    var c = 0;
    var n = num.toString();
    while (n.length > 1) {
      c += 1;
      n = eval(n.split('').join('+')).toString();
    }
    return c;
  }
  AdditivePersistence(readline());     

//29. Multiplicative Persistence - return its multiplicative persistence which is the number of times you must multiply the digits in num until you reach a single digit. For example: if num is 39 then your program should return 3 because 3 * 9 = 27 then 2 * 7 = 14 and finally 1 * 4 = 4 and you stop at 4. 
  ////??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????
//WILL'S, doesn't work?
function MultiplicativePersistence(num) { 
var c = 0; //counter
var res = num; //result

function check(res) {
    for (i=0;i<res.length;i++){
      res += Number(arguments[i]);
    }
    if (res.length==1) {
        return c; //the exit condition to the recursive call
    } else {
        c++;
        return check(res); //the recursive call
    }
}
check(res); //function call
}
MultiplicativePersistence(123);                            
	
//30. Off Line Minimum - The input will be in the following format: ["I","I","E","I",...,"E",...,"I"] where the I's stand for integers and the E means take out the smallest integer currently in the whole set. When finished, your program should return that new set with integers separated by commas. For example: if strArr is ["5","4","6","E","1","7","E","E","3","2"] then your program should return 4,1,5.*/

//WILL'S
function OffLineMinimum(array) { 
	var aset = [];
	var res = '';

	for (i=0; i<array.length; i++){
		if (aset.indexOf(array[i]) === -1 && array[i] !== 'E'){
			aset.push(array[i]);
		} else if (array[i] == 'E'){
		    res += aset.sort().shift();
	      	if (array.lastIndexOf("E") !== i){
		    	res += ",";
	        }
		}
	}
	return res;
}	
OffLineMinimum(["5","4","6","E","1","7","E","E","3","2"]); //returns 4,1,5

















</script>